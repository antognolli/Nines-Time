#!/usr/bin/python
#
# Bruno Dilly, Joao Vita, Rafael Antognolli and Leandro Pereira wrote this file.
# As long as you retain this notice you can do whatever you want with this stuff. If we
# meet some day, and you think this stuff if worth it, you can buy me a beer in return.
#

from os.path import abspath, join
from ecore.evas import SoftwareX11
from ecore import main_loop_begin, main_loop_quit, animator_frametime_set, \
        timer_add
from edje import Edje
from evas import ClippedSmartObject, Rectangle
from collections import defaultdict
from functools import partial
from time import strftime, gmtime
from emotion import Emotion
from random import Random

DATA_DIR = abspath("./data")
THEME = join(DATA_DIR, "theme", "default.edj")
MENU_MUSIC = "flanicx_-_2_dias_(synth_wave_gap_solo).mp3"
GAME_MUSIC = "annabloom_-_Percussion_Loops_1a_(5_4).mp3"
OPS_SOUND = "111872__candlegravity__tweak_scratch_2.wav"
RIGHT_SOUND = "111877__candlegravity__zipper_1.wav"
WRONG_SOUND = "111873__candlegravity__tweat_down_1.wav"


class Operation:
    def __init__(self, game, signal):
        self.signal = signal
        self.game = game
        self.cooldown = 0
        self.game.part_drag_value_set(self.signal + "_block", 0, 0)

    def decrease_cooldown(self):
        self.cooldown = self.cooldown - 4
        drag = self.cooldown / 100.
        self.game.part_drag_value_set(self.signal + "_block", 0, drag)
        if not drag:
            self.game.signal_emit(self.signal + "_hi", "")
        return self.cooldown

    def fire(self):
        if self.cooldown:
            return
        self.game.signal_emit(self.signal, "")
        Hooks.fire("sound", OPS_SOUND)
        self.cooldown = 100
        timer_add(0.1, self.decrease_cooldown)
        self.game.signal_emit(self.signal, "")
        drag = self.cooldown / 100.
        self.game.part_drag_value_set(self.signal + "_block", 0, drag)


class Player:
    def  __init__(self, ee):
        game = ee.data["game"]
        self.minus = Operation(game, "minus")
        self.plus = Operation(game, "plus")
        self.times = Operation(game, "times")
        self.over = Operation(game, "over")
        self.score = 0
        self.ee = ee

    def score_inc(self, delta):
        self.score = self.score + delta


class Hooks:
    hooks = defaultdict(list)

    @staticmethod
    def add(kind, fn, *args, **kwargs):
        Hooks.hooks[kind].append(partial(fn, *args, **kwargs))

    @staticmethod
    def fire(kind, *args, **kwargs):
        for hook in Hooks.hooks[kind]:
            hook(*args, **kwargs)


class RandomGen:

    ops = ('+', '-', '*')
    interval = 3.0 # seconds

    def __init__(self, cb=None, seed=None):
        self.random = Random()
        self.random.seed(seed)
        self.timer = None
        self.cb = cb

    def __del__(self):
        if self.timer:
            self.timer.delete()
            self.timer = None

    def _timer_cb(self):
        n1, n2 = self.get_pair()
        op = self.get_op()

        if n1 < n2:
            n1, n2 = n2, n1

        if self.cb:
            self.cb((n1, n2), op)
        return True

    def get_number(self):
        return self.random.randint(0, 8)

    def get_pair(self):
        return (self.get_number(), self.get_number())

    def get_op(self):
        return self.random.choice(self.ops)

    def set_interval(self, interval):
        self.interval = interval
        self.timer.delete()
        self.timer = timer_add(interval, self._timer_cb)

    def start(self):
        self.timer = timer_add(self.interval, self._timer_cb)

    def stop(self):
        self.timer.delete()
        self.timer = None

    def is_running(self):
        return self.timer


def resize_cb(ee):
    for d in ["bg", "menu", "game", "win", "lose"]:
        ee.data[d].size = ee.evas.size

class Screen:
    def __init__(self, ee, name, on_show_hook_name=None):
        self.ee = ee
        self.screen = Edje(ee.evas, file=THEME, group=name)
        self.screen.size = ee.evas.size
        ee.data[name] = self.screen
        if on_show_hook_name:
            Hooks.add(on_show_hook_name, self.on_show)
        else:
            Hooks.add(name, self.on_show)
        self.screen.on_key_down_add(self.on_key_down)

        self.give_focus()

    def on_show(self):
        pass

    def on_key_down(self):
        pass

    def hide(self):
        self.lose_focus()
        self.screen.hide()

    def show(self):
        self.screen.show()
        self.give_focus()

    def give_focus(self):
        self.screen.focus = True

    def lose_focus(self):
        self.screen.focus = False

class WinScreen(Screen):
    def __init__(self, ee):
        Screen.__init__(self, ee, "win")

    def on_show(self):
        self.give_focus()
        self.show()

    def on_key_donw(self, obj, event):
        kn = event.keyname
        if kn == "Escape":
            self.hide()
            Hooks.fire("show_menu")

class LoseScreen(Screen):
    def __init__(self, ee):
        Screen.__init__(self, ee, "lose")

    def on_show(self):
        self.give_focus()
        self.show()

    def on_key_down(self, obj, event):
        kn = event.keyname
        if kn == "Escape":
            self.hide()
            Hooks.fire("show_menu")

class VisualNumber:
    def __init__(self, canvas, number):
        color = (255, number * 20, 0, 255)
        self.img = Rectangle(canvas)
        self.img.resize(50, 50)
        self.img.color_set(*color)
        self.img.show()
        self.number = number

    def __del__(self):
        self.img.delete()

    def __str__(self):
        return str(self.number)

    def move(self, x, y):
        self.img.move(x, y)

    def size(self):
        return self.img.size

    def number(self):
        return self.number


class NumbersArea(ClippedSmartObject):
    def __init__(self, canvas):
        ClippedSmartObject.__init__(self, canvas)
        self.numbers = []
        self.n1 = None
        self.n2 = None
        self.op = None

    def add(self, number):
        self.numbers.append(VisualNumber(self.evas, number))

    def add_tuple(self, pair, op):
        if self.n1 != None and self.n2 != None and self.op != None:
            mystr = str(self.n1) + ' ' + self.op + ' ' + str(self.n2)
            number = eval(mystr)
            visual_number = VisualNumber(self.evas, number)
            pos_x = self.pos[0] + self.size[0] / 2 - visual_number.size()[0] / 2
            pos_y = self.pos[1] + 50
            visual_number.move(pos_x, pos_y)
            self.numbers.append(visual_number)

        self.n1 = VisualNumber(self.evas, pair[0])
        self.n2 = VisualNumber(self.evas, pair[1])
        self.op = op

    def clear(self):
        self.numbers = []
        self.n1 = None
        self.n2 = None
        self.op = None

    def resize(self, w, h):
        print "resized to:", (w, h)


class GameScreen(Screen):
    def __init__(self, ee):
        Screen.__init__(self, ee, "game", on_show_hook_name="start_game")
        self.numbers_area = NumbersArea(ee.evas)
        self.screen.part_swallow("numbers_area", self.numbers_area)

    def _tick(self):
        self.ee.data["time"] = self.ee.data["time"] - 1
        time = strftime("%M:%S", gmtime(self.ee.data["time"]))
        self.ee.data["game"].part_text_set("time", time)
        if (self.ee.data["time"] < 1):
            game.hide()
            Hooks.fire("win")
            return False
        return True

    def _gen_cb(self, pair, op):
        print "pair =", pair, ", op =", op
        self.numbers_area.add_tuple(pair, op)

    def on_show(self):
        self.ee.data["game"].part_text_set("time", "09:00")
        self.ee.data["time"] = 540
        self.ee.data["timer"] = timer_add(1, self._tick)
        Hooks.fire("music", GAME_MUSIC)
        self.ee.data["player"] = Player(self.ee)
        self.ee.data["randomgen"] = RandomGen(self._gen_cb)
        self.ee.data["randomgen"].start()
        self.give_focus()
        self.show()

    def on_key_down(self, obj, event):
        kn = event.keyname
        if kn == "Escape":
            self.ee.data.pop("timer").delete()
            print "should delete randomgen"
            self.ee.data["randomgen"].stop()
            del self.ee.data["randomgen"]
            self.numbers_area.clear()
            self.hide()
            Hooks.fire("show_menu")
        elif kn in ["equal", "KP_Add"]:
            self.ee.data["player"].plus.fire()
        elif kn in ["minus", "KP_Subtract"]:
            self.ee.data["player"].minus.fire()
        elif kn in ["8", "KP_Multiply"]:
            self.ee.data["player"].times.fire()
        elif kn in ["slash", "KP_Divide"]:
            self.ee.data["player"].over.fire()

class MenuScreen(Screen):
    def __init__(self, ee):
        Screen.__init__(self, ee, "menu", on_show_hook_name="show_menu")
        Hooks.fire("music", MENU_MUSIC)

    def on_show(self):
        self.give_focus()
        Hooks.fire("music", MENU_MUSIC)
        self.show()

    def on_key_down(self, obj, event):
        kn = event.keyname
        if kn  == "Escape":
            main_loop_quit()
        elif kn == "Return":
            self.hide()
            Hooks.fire("start_game")

def sweet_emotion(ee):
    def play(player, source = ""):
        if source:
            file_path = join(DATA_DIR, "sound", source)
        else:
            file_path = player.file
        player.file = ""
        player.file = file_path
        player.play = True

    music_player = Emotion(ee.evas, module_filename="gstreamer")
    music_player.on_playback_finished_add(play)
    sound_player = Emotion(ee.evas, module_filename="gstreamer")
    Hooks.add("music", play, music_player)
    Hooks.add("sound", play, sound_player)

def game_main():
    # FIXME get it from a file so user don't need to change it every time
    screen_size = (400, 600)
    ee = SoftwareX11(w=screen_size[0], h=screen_size[1])

    canvas = ee.evas
    bg = canvas.Rectangle(color=(0, 0, 0, 255))
    bg.size = canvas.size
    bg.show()

    ee.data["bg"] = bg
    ee.data["score"] = 0
    # FIXME get it from a file
    ee.data["hi-score"] = 0
    ee.size_min_set(*screen_size)
    ee.callback_resize = resize_cb
    ee.title = "Nines Time"

    sweet_emotion(ee)

    menu = MenuScreen(ee)
    game = GameScreen(ee)
    win = WinScreen(ee)
    lose = LoseScreen(ee)

    menu.show()

    # Sets the framerate of the game to 60FPS
    animator_frametime_set(1.0 / 60.0)

    ee.show()
    main_loop_begin()

    del canvas
    del ee


if __name__ == "__main__":
    game_main()
